---
---

<section class="travel-map">
  <p>I've been lucky to have travelled a lot. Here are places I've visited.</p>
  <div class="travel-map__container">
    <div class="travel-map__svg"></div>
    <div class="travel-map__tooltip" aria-hidden="true"></div>
    <div class="travel-map__controls">
      <button class="travel-map__zoom-btn" data-zoom="in" aria-label="Zoom in">+</button>
      <button class="travel-map__zoom-btn" data-zoom="out" aria-label="Zoom out">&minus;</button>
    </div>
  </div>
</section>

<style lang="scss">
  @use '../styles/abstracts' as *;

  .travel-map {
    margin: 75px 0;

    p {
      font-size: $font-size-md;
      line-height: $line-height-base;
      letter-spacing: $letter-spacing-body;
      margin-bottom: $spacing-unit * 3;
    }

    &__container {
      position: relative;
      width: 100%;
      margin: 0 auto;
      overflow: hidden;

      &.zoomed {
        cursor: grab;

        &:active {
          cursor: grabbing;
        }
      }
    }

    &__svg {
      width: 100%;
      height: 100%;
      transform-origin: 0 0;

      :global(svg) {
        width: 100%;
        height: 100%;
        display: block;
      }

      :global(.st4),
      :global(.st3),
      :global(.st1) {
        transition: fill $transition-fast;
      }

      :global(.st4.visited),
      :global(.st3.visited),
      :global(.st1.visited),
      :global(g.visited) > :global(*) {
        fill: #888;
        cursor: pointer;
        transition: fill $transition-fast;
      }

      :global(.st4.visited:hover),
      :global(.st3.visited:hover),
      :global(.st1.visited:hover),
      :global(g.visited:hover) > :global(*),
      :global(.st4.visited.hover),
      :global(.st3.visited.hover),
      :global(.st1.visited.hover) {
        fill: var(--color-link);
        fill-opacity: 0.35;
      }
    }

    &__tooltip {
      position: absolute;
      padding: 4px 8px;
      color: var(--color-bg);
      background: var(--color-text);
      font-family: 'Sixtyfour', monospace;
      font-size: 0.7em;
      letter-spacing: 0.03em;
      word-spacing: -0.3em;
      line-height: 1.4;
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      transition: opacity $transition-fast;
      transform: translateX(-50%);
      z-index: 15;
      display: flex;
      align-items: center;
      gap: 4px;

      :global(.flag) {
        font-size: 2.75em;
        line-height: 1;
      }

      &.visible {
        opacity: 1;
      }

      &::after {
        content: '';
        position: absolute;
        top: calc(100% - 1px);
        left: 50%;
        transform: translateX(-50%);
        width: 10px;
        height: 6px;
        background: var(--color-text);
        clip-path: polygon(0 0, 100% 0, 50% 100%);
      }
    }

    &__controls {
      position: absolute;
      bottom: $spacing-unit * 2;
      right: $spacing-unit * 2;
      display: flex;
      flex-direction: column;
      gap: 4px;
      z-index: 10;
    }

    &__zoom-btn {
      width: 32px;
      height: 32px;
      border: 1px solid var(--color-text);
      background: var(--color-bg);
      color: var(--color-text);
      font-size: $font-size-md;
      line-height: 1;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;

      &:hover {
        background: var(--color-text);
        color: var(--color-bg);
      }
    }
  }
</style>

<script>
  // Map exact SVG element IDs to place names
  // Each landmass is its own entry so they highlight independently
  const visitedPlaces: Record<string, { name: string; flag: string }> = {
    // North America
    US1: { name: 'United States', flag: '\u{1F1FA}\u{1F1F8}' },
    US2_1: { name: 'Hawaii', flag: '\u{1F1FA}\u{1F1F8}' },
    US2_2: { name: 'Hawaii', flag: '\u{1F1FA}\u{1F1F8}' },
    US2_3: { name: 'Hawaii', flag: '\u{1F1FA}\u{1F1F8}' },
    US2_4: { name: 'Hawaii', flag: '\u{1F1FA}\u{1F1F8}' },
    US2_5: { name: 'Hawaii', flag: '\u{1F1FA}\u{1F1F8}' },
    US2_6: { name: 'Hawaii', flag: '\u{1F1FA}\u{1F1F8}' },
    US2_7: { name: 'Hawaii', flag: '\u{1F1FA}\u{1F1F8}' },
    US2_8: { name: 'Hawaii', flag: '\u{1F1FA}\u{1F1F8}' },
    CA1: { name: 'Canada', flag: '\u{1F1E8}\u{1F1E6}' },
    MX1: { name: 'Mexico', flag: '\u{1F1F2}\u{1F1FD}' },

    // Caribbean
    CU1: { name: 'Cuba', flag: '\u{1F1E8}\u{1F1FA}' },
    BS1: { name: 'Bahamas', flag: '\u{1F1E7}\u{1F1F8}' },
    AG1: { name: 'Antigua and Barbuda', flag: '\u{1F1E6}\u{1F1EC}' },
    BL1: { name: 'St Barts', flag: '\u{1F1E7}\u{1F1F1}' },
    DO1: { name: 'Dominican Republic', flag: '\u{1F1E9}\u{1F1F4}' },
    KY1: { name: 'Cayman Islands', flag: '\u{1F1F0}\u{1F1FE}' },

    // South America
    BR1: { name: 'Brazil', flag: '\u{1F1E7}\u{1F1F7}' },

    // Europe
    FR1: { name: 'France', flag: '\u{1F1EB}\u{1F1F7}' },
    GB1: { name: 'United Kingdom', flag: '\u{1F1EC}\u{1F1E7}' },
    IE1: { name: 'Ireland', flag: '\u{1F1EE}\u{1F1EA}' },
    IT1: { name: 'Italy', flag: '\u{1F1EE}\u{1F1F9}' },
    DE1: { name: 'Germany', flag: '\u{1F1E9}\u{1F1EA}' },
    GR1: { name: 'Greece', flag: '\u{1F1EC}\u{1F1F7}' },
    TR1: { name: 'Turkey', flag: '\u{1F1F9}\u{1F1F7}' },
    IL1: { name: 'Israel', flag: '\u{1F1EE}\u{1F1F1}' },

    // Africa
    EG1: { name: 'Egypt', flag: '\u{1F1EA}\u{1F1EC}' },
    ZA1: { name: 'South Africa', flag: '\u{1F1FF}\u{1F1E6}' },
    SC1: { name: 'Seychelles', flag: '\u{1F1F8}\u{1F1E8}' },

    // Asia
    IN1: { name: 'India', flag: '\u{1F1EE}\u{1F1F3}' },
    KH1: { name: 'Cambodia', flag: '\u{1F1F0}\u{1F1ED}' },
    VN1: { name: 'Vietnam', flag: '\u{1F1FB}\u{1F1F3}' },
    SG1: { name: 'Singapore', flag: '\u{1F1F8}\u{1F1EC}' },
    CN1: { name: 'China', flag: '\u{1F1E8}\u{1F1F3}' },
    JP1: { name: 'Japan', flag: '\u{1F1EF}\u{1F1F5}' },
  };

  fetch('/maps/8bit-world-map.svg')
    .then(res => res.text())
    .then(svgText => {
      const svgContainer = document.querySelector('.travel-map__svg') as HTMLElement;
      if (!svgContainer) return;

      svgContainer.innerHTML = svgText;

      // Mark visited places by exact element ID
      for (const id of Object.keys(visitedPlaces)) {
        const el = svgContainer.querySelector(`#${id}`);
        if (el) el.classList.add('visited');
      }

      // Enclaves: move these after their enclosing country so they paint on top
      const enclaves: [string, string][] = [['LS1', 'ZA1'], ['MN1', 'CN1']]; // [enclave, encloser]
      for (const [enclaveId, encloserId] of enclaves) {
        const enclave = svgContainer.querySelector(`#${enclaveId}`);
        const encloser = svgContainer.querySelector(`#${encloserId}`);
        if (enclave && encloser) encloser.after(enclave);
      }

      // Expand hit area for tiny countries with an invisible rect over them
      const hitPadding = 12; // SVG units around the element
      const tinyCountries = ['SC1'];

      // Group hit area for Hawaii â€” one rect covering all islands
      const hawaiiIds = ['US2_1', 'US2_2', 'US2_3', 'US2_4', 'US2_5', 'US2_6', 'US2_7', 'US2_8'];
      const hawaiiEls = hawaiiIds
        .map(id => svgContainer.querySelector(`#${id}`) as SVGGraphicsElement | null)
        .filter((el): el is SVGGraphicsElement => el !== null);
      if (hawaiiEls.length > 0) {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        for (const el of hawaiiEls) {
          const b = el.getBBox();
          if (b.width === 0 && b.height === 0) continue;
          minX = Math.min(minX, b.x);
          minY = Math.min(minY, b.y);
          maxX = Math.max(maxX, b.x + b.width);
          maxY = Math.max(maxY, b.y + b.height);
        }
        const hitRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        hitRect.setAttribute('x', String(minX - hitPadding));
        hitRect.setAttribute('y', String(minY - hitPadding));
        hitRect.setAttribute('width', String(maxX - minX + hitPadding * 2));
        hitRect.setAttribute('height', String(maxY - minY + hitPadding * 2));
        hitRect.setAttribute('fill', 'transparent');
        hitRect.setAttribute('data-hit-for', 'US2_1');
        hitRect.setAttribute('data-hit-group', hawaiiIds.join(','));
        hitRect.style.cursor = 'pointer';
        hawaiiEls[0].after(hitRect);
      }
      for (const id of tinyCountries) {
        const el = svgContainer.querySelector(`#${id}`) as SVGGraphicsElement | null;
        if (!el) continue;
        const bbox = el.getBBox();
        const hitRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        hitRect.setAttribute('x', String(bbox.x - hitPadding));
        hitRect.setAttribute('y', String(bbox.y - hitPadding));
        hitRect.setAttribute('width', String(bbox.width + hitPadding * 2));
        hitRect.setAttribute('height', String(bbox.height + hitPadding * 2));
        hitRect.setAttribute('fill', 'transparent');
        hitRect.setAttribute('data-hit-for', id);
        hitRect.style.cursor = 'pointer';
        // Insert after the element so it sits on top and catches pointer events
        el.after(hitRect);
      }

      const mapContainer = document.querySelector('.travel-map__container') as HTMLElement;
      const tooltip = document.querySelector('.travel-map__tooltip') as HTMLElement;

      // --- Zoom & Pan ---
      let scale = 1;
      let panX = 0;
      let panY = 0;
      const MIN_SCALE = 1;
      const MAX_SCALE = 8;
      const ZOOM_STEP = 0.3;

      function applyTransform() {
        svgContainer.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
        mapContainer.classList.toggle('zoomed', scale > 1);
      }

      function clampPan() {
        const rect = mapContainer.getBoundingClientRect();
        const contentW = rect.width * scale;
        const contentH = rect.height * scale;
        const maxPanX = 0;
        const minPanX = rect.width - contentW;
        const maxPanY = 0;
        const minPanY = rect.height - contentH;
        panX = Math.min(maxPanX, Math.max(minPanX, panX));
        panY = Math.min(maxPanY, Math.max(minPanY, panY));
      }

      function zoomAt(clientX: number, clientY: number, delta: number) {
        const rect = mapContainer.getBoundingClientRect();
        const mouseX = clientX - rect.left;
        const mouseY = clientY - rect.top;

        const prevScale = scale;
        scale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, scale + delta));

        // Adjust pan so zoom centers on mouse position
        const ratio = scale / prevScale;
        panX = mouseX - ratio * (mouseX - panX);
        panY = mouseY - ratio * (mouseY - panY);

        clampPan();
        applyTransform();
      }

      // Mouse wheel zoom
      mapContainer.addEventListener('wheel', (e: WheelEvent) => {
        e.preventDefault();
        const delta = e.deltaY < 0 ? ZOOM_STEP : -ZOOM_STEP;
        zoomAt(e.clientX, e.clientY, delta);
      }, { passive: false });

      // Button zoom (centers on map)
      mapContainer.querySelectorAll('.travel-map__zoom-btn').forEach(btn => {
        btn.addEventListener('click', (e: Event) => {
          e.stopPropagation();
          const rect = mapContainer.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          const direction = (btn as HTMLElement).dataset.zoom;
          const delta = direction === 'in' ? ZOOM_STEP : -ZOOM_STEP;
          zoomAt(centerX, centerY, delta);
        });
      });

      // Pan via mouse drag
      let isPanning = false;
      let startX = 0;
      let startY = 0;
      let startPanX = 0;
      let startPanY = 0;

      mapContainer.addEventListener('mousedown', (e: MouseEvent) => {
        if (scale <= 1) return;
        isPanning = true;
        startX = e.clientX;
        startY = e.clientY;
        startPanX = panX;
        startPanY = panY;
      });

      window.addEventListener('mousemove', (e: MouseEvent) => {
        if (!isPanning) return;
        panX = startPanX + (e.clientX - startX);
        panY = startPanY + (e.clientY - startY);
        clampPan();
        applyTransform();
      });

      window.addEventListener('mouseup', () => {
        isPanning = false;
      });

      // --- Tooltip ---
      if (!tooltip) return;

      // Per-country tooltip Y nudge (positive = lower)
      const tooltipNudge: Record<string, number> = {
        CN1: 10,
      };

      function positionTooltip(el: SVGGraphicsElement) {
        const elRect = el.getBoundingClientRect();
        const containerRect = mapContainer.getBoundingClientRect();
        const centerX = elRect.left + elRect.width / 2 - containerRect.left;
        const tooltipH = tooltip.offsetHeight + 6; // 6px arrow
        const tooltipW = tooltip.offsetWidth;
        const nudge = tooltipNudge[el.id] ?? 0;
        // Position at 1/3 from top (2/3 up from bottom) of the element
        const y = elRect.top + elRect.height * 0.33 - containerRect.top - tooltipH - 4 + nudge;

        // Clamp horizontally so tooltip doesn't overflow the container
        const minLeft = tooltipW / 2;
        const maxLeft = containerRect.width - tooltipW / 2;
        const clampedX = Math.min(maxLeft, Math.max(minLeft, centerX));

        tooltip.style.left = `${clampedX}px`;
        tooltip.style.top = `${y}px`;
      }

      svgContainer.querySelectorAll('.visited').forEach(path => {
        path.addEventListener('mouseenter', () => {
          const target = path as SVGGraphicsElement;
          const place = visitedPlaces[target.id];
          if (!place) return;

          tooltip.innerHTML = `<span class="flag">${place.flag}</span> ${place.name}`;
          tooltip.classList.add('visible');
          positionTooltip(target);
        });

        path.addEventListener('mouseleave', () => {
          tooltip.classList.remove('visible');
        });
      });

      // Bind hit rects to their country's tooltip and hover highlight
      svgContainer.querySelectorAll('[data-hit-for]').forEach(hitRect => {
        const countryId = hitRect.getAttribute('data-hit-for')!;
        const groupAttr = hitRect.getAttribute('data-hit-group');
        const targetIds = groupAttr ? groupAttr.split(',') : [countryId];
        const targetEls = targetIds
          .map(id => svgContainer.querySelector(`#${id}`) as SVGGraphicsElement | null)
          .filter((el): el is SVGGraphicsElement => el !== null);
        if (targetEls.length === 0) return;

        hitRect.addEventListener('mouseenter', () => {
          const place = visitedPlaces[countryId];
          if (!place) return;
          targetEls.forEach(el => el.classList.add('hover'));
          tooltip.innerHTML = `<span class="flag">${place.flag}</span> ${place.name}`;
          tooltip.classList.add('visible');
          // Position tooltip using the hit rect itself for grouped elements
          positionTooltip(hitRect as unknown as SVGGraphicsElement);
        });

        hitRect.addEventListener('mouseleave', () => {
          targetEls.forEach(el => el.classList.remove('hover'));
          tooltip.classList.remove('visible');
        });
      });
    })
    .catch(() => {});
</script>
